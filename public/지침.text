아래는 **사용자 지침 + GPT 1차 + GPT 2차**를 합쳐 정리한 최종 운영 지침입니다. 불필요한 말 빼고, 딱 실행 기준만 모았습니다.

# 1) 공통 규약

## 1.1 파일/환경/요청 파이프라인

* 모든 페이지는 `inc/common.php`를 로드해 **$con(MySQLi)** 로 DB 쿼리 수행.
* 공통 응답은 전역 **$response** 배열에 담고 **Finish()**로 종료(항상 JSON).
* 모든 `$_POST`, `$_GET`은 **`_ajax_.php`를 반드시 경유**하고 `decryptArrayRecursive()`로 복호화 후 사용.
* 서버에서 내려주는 민감/구조 데이터는 필요 시 `encryptValue()`(재귀 적용)로 암호화 가능.

  * 입력값(프런트→서버)은 암호화 **하지 않는다**.

## 1.2 응답 포맷(표준)

* `$response = ['result'=>'ok|error', 'msg'=>'메시지', 'item'=>{...옵션}]`
* 모든 종료는 **Finish()** 한 번으로 통일.

## 1.3 트랜잭션/검증/로그

* 관련 엔터티를 함께 생성/갱신하는 작업은 **트랜잭션** 적용(성공 시 커밋, 실패 시 롤백).
* 공통 검증: 이메일 형식/중복, 필수값 체크, 권한 검사.
* 감사 로그 테이블 존재 시 주요 상태 변경/로그인 등은 기록(로그 실패가 본처리를 막지 않도록 예외 삼킴).

---

# 2) 데이터베이스/ID/스키마 규약

## 2.1 핵심 테이블 및 키 타입

* `roles`

  * `code ∈ {'HQ','VENDOR','CUSTOMER'}` (없으면 자동 시드)
* `users`

  * PK: **BIGINT UNSIGNED AUTO_INCREMENT**, `role_id` FK(roles)
  * 선택 연결용: `vendor_id`(VARCHAR), `customer_id`(VARCHAR) — 초기 단계 FK 생략 가능
* `vendors / customers / sites`

  * 고객 연락처: `billing_contact`, `shipping_contact`는 **JSON**
* `user_extra`

  * `user_id`는 **users.user_id와 동일 타입(BIGINT UNSIGNED)** 로 FK
* `audit_log`

  * `actor_user_id` → `users.user_id`(동일 타입)

> FK 재구성/드롭 순서
>
> 1. `SET FOREIGN_KEY_CHECKS=0`
> 2. **자식 → 부모** 순서로 드롭
> 3. `SET FOREIGN_KEY_CHECKS=1`
> 4. **부모 → 자식** 순서로 재생성
> 5. FK 컬럼 타입/Unsigned/NULL/인덱스 일치 확인

## 2.2 식별자/코드 정책

* 가변 ID 생성 규칙:

  * `vendors.vendor_id`: **VYYYYMMDDNNNN**
  * `customers.customer_id`: **CYYYYMMDDNNNN**
  * `sites.site_id`: **SYYYYMMDDNNNN**
* 타임스탬프 기본값: `created_at DEFAULT CURRENT_TIMESTAMP`

## 2.3 스키마 호환성/동적 INSERT

* `SHOW COLUMNS`로 **존재하는 컬럼만 INSERT/UPDATE** 하는 동적 바인딩 패턴 권장(스키마 차이 흡수).
* ENUM/체크 제약은 서비스 정책과 맞춰 최소·명확하게 사용.

---

# 3) 화면/흐름/권한/메뉴 규약

## 3.1 회원가입(멤버 등록) 흐름

* 가입 타입: **HQ / VENDOR / CUSTOMER**
* 공통 검증: 이메일 필수/형식/중복, 비밀번호=확인, 이름 필수
* 타입별 처리:

  * **HQ**: `users(role=HQ)`만 생성
  * **VENDOR**: `vendors` 생성 → `users(role=VENDOR, vendor_id)` 생성
  * **CUSTOMER**: `customers` 생성(+ 주소 있으면 `sites` 기본 ‘본점’ 생성 가능) → `users(role=CUSTOMER, customer_id)` 생성
* 역할 보장: `roles`에 코드 없으면 자동 삽입 후 `role_id` 매핑
* 비밀번호 저장: **password_hash(BCRYPT)**
* 트랜잭션으로 일괄 처리

## 3.2 로그인 흐름

* 입력 모드: **이메일** / **아이디** 전환 지원

  * 이메일 모드: `users.email`
  * 아이디 모드: `users.login_id` → `users.userid` → `user_extra.userid` 우선순위 조회
* 인증: `password_verify()` / `is_active=0` 차단 / `last_login=NOW()` 갱신(존재 시)
* 감사 로그 존재 시 `LOGIN` 기록(실패는 본처리에 영향 주지 않음)
* 성공 후 이동:

  1. 항상 `index.html` 로드
  2. 이후 모든 화면 전환은 **AJAX 전용**
  3. 서버 응답 내 **doc_base(암호화 가능)** 를 복호화하여 초기 문서와 라우팅 결정

     * 역할→문서 베이스: `HQ → doc/hq`, `VENDOR → doc/vendor`, `CUSTOMER → doc/customer`
     * 초기 페이지: `doc/{role}/index`
     * 메뉴 클릭: `doc_base + '/' + {path}`

## 3.3 메뉴/라우팅 규칙

* **ID 규칙(전역 유일)**: **그룹 첫글자(대문자) + 2자리 숫자**

  * HQ: `H01`, `H02` …
  * VENDOR: `V01` …
  * CUSTOMER: `C01` …
* **PATH 규칙**: **영문 숏네임**, 확장자 미포함(e.g., `dashboard`, `customer_mgmt`, `work_orders`)
* 라우팅은 **path 기준**(현재 합의); AJAX 로더가 `doc/{role}/{path}` 템플릿을 로드

## 3.4 프런트 규칙(요약)

* 페이지 전체 리로드 금지, **AJAX만** 사용
* 서버가 내려주는 `item`(redirect, role, doc_base, route_rule 등)은 필요 시 암호화되어 전달; 프런트는 사용 시 복호화

---

# 4) 보안/운영 팁

* 입력값은 복호화 후 서버측 **화이트리스트 검증** 적용
* 트랜잭션 경계는 “엔터티-일관성” 단위로 최소화해 락 경합 줄이기
* 스키마 변경 시: 부모 PK가 **PK/UNIQUE & 타입 일치**인지 `SHOW CREATE TABLE`, `SHOW INDEX`로 재확인
* 장애 메시지는 `$response['msg']`에만 담아 노출. 내부 예외/스택은 로그로만 저장

---

이 지침을 **기본 운영 표준**으로 삼고, 코드/화면은 위 규약을 전제로 작성·검수한다.
